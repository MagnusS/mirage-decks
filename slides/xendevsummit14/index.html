<section data-markdown class="title center">
  <script type="text/template">
    # __MirageOS 2.0__ branch consistency_<br />for Xen Stub Domains<br />

    Anil Madhavapeddy <small>University of Cambridge</small> [@avsm](http://twitter.com/avsm)
    <br />

    <div style="font-size: 24pt">
      [http://openmirage.org](http://openmirage.org)
      <br />
      [http://decks.openmirage.org/xendevsummit14/](http://decks.openmirage.org/xendevsummit14/#/)
    </div>
 </script>
</section>

<section>
  <section data-markdown>
    <script type="text/template">
    ## These Slides

    - Self-hosted on a 1MB Xen microkernel on ARM <small>(Provided Anil's cubieboard wasn't conficated at the airport)</small>
    - Fully type-safe OCaml, including the device drivers and TCP stack.
    - Hosted online at <http://decks.openmirage.org> too with more slides.


    <p class="stretch center">
      <img src="decks-on-arm.png" />
    </p>


    </script>
  </section>
</section>

<section>

  <section data-markdown>
    <script type="text/template">
      ## Irmin: storage for Mirage 2.0

      **Irmin** is our *library database* that follows the modular
      design principles of MirageOS: <https://github.com/mirage/irmin>

      <br />

      - Runs in both **userspace** and **kernelspace**
      - A **key = value** store (sound familiar?)
      - **Git-style**: commit, branch, merge
      - **Preserves history** by default
      - **Backend support** for in-memory, Git and HTTP/REST stores.

      <br/>Mirage unikernels thus version control all their data,
      and have a **distributed provenance graph** of all activities.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Base Concepts

      ![store](./store.png)

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Base Concepts

      ### Object DAG

      - Append-only & Distributed
      - Stable serialisation of structured values
      - similar to heap representation
        - with position/architecture independent pointers (such as SHA1 of blocks)
        - backend independence (memory, on-disk, encryption, etc...)

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Base Concepts

      ### History DAG

      - Append-only & Distributed
      - Keep track of history
      - Can be stored in the Object DAG store
      - Useful for audit
      - Useful for merge (3-way merge is easier than 2-way)
      - Snapshot / Revert for free

    </script>
  </section>


</section>
<section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: VM metadata on Xen

    **Xenstore** is our *configuration database* that stores VM metadata
    in directories (Ã  la Plan 9) with a transactional update mechanism.

    <br />

    - Runs in either **userspace** or **kernelspace** (just like Mirage)
    - **A key = value** store (just like Irmin)
    - XS_TRANSACTION_START (**branch**); XS_TRANSACTION_END (**merge**)
    - **Logs history** by default (just like Irmin... <small>hmm, where's he going with this?</small>)

    <br /> Unfortunately the transaction implementations all suck.
    As for distribution across hosts/clusters/clouds: don't even think about
    it.
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: conflicts

    - **Terrible performance impact** because a transaction may involve 100 RPCs to set it up (one per read/write op), only to be **aborted and retried**
    - The longer a transaction is open, the **greater the chance** of a conflict with a shorter transaction, causing a repeat of the longer transaction.
    - Concurrent transactions can lead to **live-lock**
      - Try starting lots of VMs in parallel!
      - Lots of time spent removing transactions (eg from ```xend```)

    <br/>Conflicts between xenstore transactions are so devastating, people try hard to avoid transactions altogether. However they aren't going away.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: conflicts

    - Observe: typical Xenstore transactions (eg creating domains)
      **shouldn't** conflict. It's the merging algorithm.
    - If we were managing domain configurations in git, we would simply
      **merge** or **rebase** and it would work.
    - Therefore the Irmin Xenstore simply does:
```
DB.View.merge_path ~origin db [] transaction >>= function
| `Ok () -> return true
| `Conflict msg ->
  (* if merge doesn't work, try rebase *)
  DB.View.rebase_path ~origin db [] transaction >>= function
  | `Ok () -> return true
  | `Conflict msg ->
    (* A true conflict: tell the client *)
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Xenstore: performance

      <img src="results.png" />
      <p class="fragment bubble "
         style="top: -270pt; left: 190pt; width: 15.5em">
        Irmin's default transaction merging algorithm 'just works' for Xen.
      </p>
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Xenstore: reliability

    What happens if Xenstore crashes?

    <br/>

     - Rings full of **partially read/written packets**. No reconnection protocol
       in common use (proposal on ```xen-devel``` but it will take years before we
       can rely on it)
     - **Per-connection state** in Xenstore: watch registrations, pending watch
       events
     - If Xenstore is restarted, many of the rings will be broken (probably
       including dom0)
     - ... you'll probably have to **reboot the host**
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Xenstore: reliability

    Irmin to the rescue!

    <br/>

     - We have data structure libraries built on top of Irmin, for example
       **mergeable queues**. Use these for (eg) pending watch events.
     - We can **persist partially read/written packets** so fragments can be
       recovered over restart
     - We can persist connection information (i.e. ring information from an
       **Introduce**) and auto-reconnect on start
     - Added bonus: easy to introspect state via ```xenstore-ls```, can see each
       registered watch, queue etc
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: debugability

    - When a bug is reported normal procedure is:
      - stare at Xenstore logs for a very long time
      - slowly deduce the state at the time the bug manifested
      - (swearing and cursing is strictly optional)

    <br/>With Irmin, one can simply ```git checkout``` to the revision, and inspect the state with ```ls```. History-preserving datastructures FTW!

```
$ git log --oneline --graph --decorate --all
...
| | * | 1787fd2 Domain 0: merging transaction 394
| | |/
| * | 0d1521c Domain 0: merging transaction 395
| |/
* | 731356e Domain 0: merging transaction 396
|/
* 8795514 Domain 0: merging transaction 365
* 74f35b5 Domain 0: merging transaction 364
* acdd503 Domain 0: merging transaction 363
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: the data

    - Xenstore contains **VM** metadata (```/vm```) and **domain** metadata (```/local/domain```)
    - But VM metadata is duplicated elsewhere and copied in/out
      - ```xl``` config files
      - ```xapi``` database
      - ... lots of other places
    - What if Xenstore could store this data, and if it could be shared and distributed?
    - What if application data could be persisted reliably to Xenstore?

    <br/>With current implementations, it is ... unwise ... to add too much data to Xenstore.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Xenstore: the data

    Irmin to the rescue!

    <br/>

    - VM metadata can be checked-in to Irmin
      - **clone** **pull** **push** to move between machines
    - could expose locally via FUSE, for Plan9 filesystem goodness
      - maybe one day even ```echo start > VM/uuid/ctl```
    - VM data could be checked-in to Irmin
      - e.g. the Mirage TCP/IP stack can serialise the state of active connections. We could _migrate_ one VM onto many VMs.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Xenstore: current state and plans

    - Advanced prototype exists using Mirage libraries, but doesn't yet pass unit test suite.

    So:

    - Fix the unit tests (obviously)
    - Write Irmin backend which operates over a fixed-size block device or ramdisk. Preserving history is a good default, but history does need to be squashed from time to time.
    - Send patches to ```xen-devel```, probably using ```opam``` to build the Mirage libraries
    - In ```xapi``` toolstack: delete existing database, replace with Xenstore
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xenstore: the code

    - Prototype, unit tests currently at: https://github.com/mirage/ocaml-xenstore-server
    - To build:
```
opam init --comp=4.01
eval `opam config env`
opam pin irmin git://github.com/mirage/irmin
opam install xenstore irmin shared-memory-ring xen-evtchn io-page
git clone git://github.com/mirage/ocaml-xenstore-server
cd ocaml-xenstore-server
make
```
    - To run:
```
./main.native --enable-unix --path /tmp/test-socket&
```
    - To test:
```
XENSTORED_PATH=/tmp/test-socket xenstore-write hello there
```
    </script>
  </section>



</section>
